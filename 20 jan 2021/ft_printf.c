/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tchariss <tchariss@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/23 11:25:18 by tchariss          #+#    #+#             */
/*   Updated: 2021/01/18 14:08:13 by tchariss         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
/*
Число 0 имеет тип int, минимальный размер которого соответствует 16 битам (2 байта), что, скорее всего, 
будет не соответствовать размеру ожидаемого в функции указателя.
stdarg.h объявляет тип va_list, и определяет четыре макрофункции: va_start, va_arg, va_copy и va_end.

Va_start принимает два аргумента, объект va_list  и ссылку на последний параметр функции (тот, что перед многоточием). 
Она инициализирует va_list объект для использования в va_arg или va_copy. Компилятор обычно выдает предупреждение, 
если ссылка неверная (например, ссылка на параметры, отличающиеся от последнего, или ссылка на совершенно другой объект).vi

Va_arg принимает два аргумента, va_list объект (ранее инициализированный) и дескриптор типа. 
Он расширяется на следующей переменной аргумент, и имеет указанный тип. Каждый следующий вызов возвращает следующий аргумент.

Va_end принимает один аргумент типа va_list и очищает его. Если вы хотели, например, сканировать переменное число аргументов более чем один раз, 
вам надо будет повторно инициализировать va_list путём вызова va_end и затем va_start.

Va_copy принимает два аргумента, оба типа va_list. 
Он дублирует второй (который должен был быть инициализирован) в первый.
*/

// stdarg - variable argument lists - список аргументов(значений) переменных
//     stdarg.h объявляет тип va_list, и определяет четыре макрофункции: va_start, va_arg, va_copy и va_end
//     предоставяет средства для перебора аргументов функции, количество и типы которых заранее не известны

// Содержимое stdarg.h часто используют в функциях с произвольным количеством аргументов (к примеру, printf, scanf)

// SYNOPSIS
// va_list: список переменных аргументов. Указатель для хранения адреса памяти аргумента переменной
// #include <stdarg.h>
// - Тип va_list служит для описания переменной, которая будет по очереди указывать на каждый из аргументов
// 	type   va_arg(va_list ap, type); -> ap (от «argument pointer» — указатель на аргумент)
// - Макрос va_arg используется для получения доступа к очередному аргументу и при каждом вызове предвигает 
// указатель ap на следующий аргумент
// - va_arg возвращает текущий аргумент
// va_arg: получает значение, равное размеру определенного типа данных, из указателя аргумента переменной.
// 	void   va_start(va_list ap, last);
// va_start: установить указатель для получения переменных аргументов
// - Макрос va_start служит для инициализации списка переменных аргументов и должен иметь соответствующий вызов va_end
// 	void   va_end(va_list ap);
// va_end: после обработки аргумента переменной инициализировать указатель значением NULL
// - После получения всех аргументов va_end сбрасывает указатель на NULL
// 	void   va_copy(va_list dest, va_list src);
// -va_copy - для копирования объектов типа va_list

// va_list - тип данных, указатель на аргументы

// вызываю парсер в принтф моем


int			ft_printf(const char *str, ...)
{
	t_flags	*str_spec;
	va_list	v1;
	char 	*s;
	int		num;
	
	s = (char *)str;
	num = 0;
	str_spec = (t_flags *)ft_calloc(sizeof(t_flags), 1); // зануляю элементы структуры
	if (str_spec == NULL)
		return (-1); //ошибка
	if (!str)
		return (0);
    va_start(v1, str);
	while (*s)
	{
		if (*s == '%')
		{
			s++;
			parser(s, str_spec, v1);
		}
		else
		num = num + write(1, s, 1);
		s++;
	}

	free(str_spec);
	va_end(v1);
	return (num);
}
